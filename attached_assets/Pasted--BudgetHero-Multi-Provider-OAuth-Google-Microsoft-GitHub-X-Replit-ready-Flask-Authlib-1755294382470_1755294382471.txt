"""
BudgetHero Multi‑Provider OAuth (Google, Microsoft, GitHub, X) — Replit‑ready

• Flask + Authlib (OAuth 2.0 / 1.0a where needed)
• Works on Replit public URL (HTTPS) — replace BASE_URL accordingly
• Clean logout, forced account selection, and easy account switching
• Issues your own JWT for API auth, stores no server sessions by default

---
SETUP (Replit):
1) Add these Secrets (Environment Variables):
   FLASK_SECRET=change_me
   JWT_SECRET=change_me
   BASE_URL=https://your-repl-name.username.repl.co

   # Google OAuth 2.0 (create at console.cloud.google.com)
   GOOGLE_CLIENT_ID=...
   GOOGLE_CLIENT_SECRET=...

   # Microsoft (Outlook) OAuth 2.0 v2 (create at portal.azure.com — App registrations)
   MS_CLIENT_ID=...
   MS_CLIENT_SECRET=...
   MS_TENANT=common   # or your tenant ID, but 'common' enables personal & work accounts

   # GitHub OAuth (https://github.com/settings/developers)
   GH_CLIENT_ID=...
   GH_CLIENT_SECRET=...

   # X (Twitter) OAuth 1.0a (Developer portal)
   TWITTER_API_KEY=...
   TWITTER_API_SECRET=...

2) In each provider’s developer console, set *authorized redirect URIs* to:
   {BASE_URL}/auth/callback/google
   {BASE_URL}/auth/callback/microsoft
   {BASE_URL}/auth/callback/github
   {BASE_URL}/auth/callback/twitter

3) Run this file on Replit. Your public HTTPS URL = BASE_URL.

4) (Optional) Enable Replit "Always On" for reliable webhooks & logins.

---
FRONTEND USAGE (example):
- GET {BASE_URL}/auth/login?provider=google      # Begins Google login (forces account chooser)
- GET {BASE_URL}/auth/login?provider=microsoft   # Outlook / Microsoft
- GET {BASE_URL}/auth/login?provider=github      # GitHub
- GET {BASE_URL}/auth/login?provider=twitter     # X (Twitter)

- POST {BASE_URL}/auth/logout                    # Clears tokens client-side (JWT is stateless)
- GET  {BASE_URL}/auth/switch?provider=google    # Convenience: logout + start login

JWT returned after callback; store it in localStorage and send as Authorization: Bearer <jwt>
"""
from __future__ import annotations
import os, json, time, base64, hmac, hashlib
from urllib.parse import urlencode

from flask import Flask, redirect, request, jsonify, make_response, url_for
from authlib.integrations.flask_client import OAuth
from authlib.integrations.requests_client import OAuth1Session

# -----------------------------
# App & Config
# -----------------------------
app = Flask(__name__)
app.secret_key = os.environ.get("FLASK_SECRET", "change_me")
BASE_URL = os.environ.get("BASE_URL", "http://localhost:5000")
JWT_SECRET = os.environ.get("JWT_SECRET", "change_me")

# Allowed providers
PROVIDERS = {"google", "microsoft", "github", "twitter"}

# -----------------------------
# Simple JWT helpers (HS256)
# -----------------------------
def jwt_encode(payload: dict, exp_seconds: int = 60*60*24*7) -> str:
    header = {"alg": "HS256", "typ": "JWT"}
    payload = dict(payload)
    payload["exp"] = int(time.time()) + exp_seconds
    def b64url(d: bytes) -> bytes:
        return base64.urlsafe_b64encode(d).rstrip(b"=")
    header_b64 = b64url(json.dumps(header, separators=(',',':')).encode())
    payload_b64 = b64url(json.dumps(payload, separators=(',',':')).encode())
    signing_input = header_b64 + b"." + payload_b64
    sig = hmac.new(JWT_SECRET.encode(), signing_input, hashlib.sha256).digest()
    token = signing_input + b"." + b64url(sig)
    return token.decode()

def jwt_decode(token: str) -> dict:
    def b64url_decode(seg: str) -> bytes:
        pad = 4 - (len(seg) % 4)
        if pad and pad < 4:
            seg += "=" * pad
        return base64.urlsafe_b64decode(seg)
    header_b64, payload_b64, sig_b64 = token.split(".")
    signing_input = (header_b64 + "." + payload_b64).encode()
    expected = hmac.new(JWT_SECRET.encode(), signing_input, hashlib.sha256).digest()
    if not hmac.compare_digest(expected, b64url_decode(sig_b64)):
        raise ValueError("Invalid signature")
    payload = json.loads(b64url_decode(payload_b64))
    if payload.get("exp", 0) < time.time():
        raise ValueError("Token expired")
    return payload

# -----------------------------
# Authlib OAuth 2 clients (Google, Microsoft, GitHub)
# -----------------------------
oauth = OAuth(app)

# Google
oauth.register(
    name="google",
    client_id=os.environ.get("GOOGLE_CLIENT_ID"),
    client_secret=os.environ.get("GOOGLE_CLIENT_SECRET"),
    access_token_url="https://oauth2.googleapis.com/token",
    authorize_url="https://accounts.google.com/o/oauth2/v2/auth",
    api_base_url="https://www.googleapis.com/oauth2/v2/",
    client_kwargs={
        "scope": "openid email profile",
        # Force account chooser every time
        "prompt": "select_account",
        "access_type": "offline",
        "include_granted_scopes": "true",
    },
)

# Microsoft (Outlook) — v2 endpoint supports personal + work
MS_TENANT = os.environ.get("MS_TENANT", "common")
oauth.register(
    name="microsoft",
    client_id=os.environ.get("MS_CLIENT_ID"),
    client_secret=os.environ.get("MS_CLIENT_SECRET"),
    access_token_url=f"https://login.microsoftonline.com/{MS_TENANT}/oauth2/v2.0/token",
    authorize_url=f"https://login.microsoftonline.com/{MS_TENANT}/oauth2/v2.0/authorize",
    api_base_url="https://graph.microsoft.com/v1.0/",
    client_kwargs={
        "scope": "openid email profile User.Read",
        # Force account selection
        "prompt": "select_account",
    },
)

# GitHub
oauth.register(
    name="github",
    client_id=os.environ.get("GH_CLIENT_ID"),
    client_secret=os.environ.get("GH_CLIENT_SECRET"),
    access_token_url="https://github.com/login/oauth/access_token",
    authorize_url="https://github.com/login/oauth/authorize",
    api_base_url="https://api.github.com/",
    client_kwargs={
        "scope": "read:user user:email",
    },
)

# -----------------------------
# Twitter (X) — OAuth 1.0a using requests client
# -----------------------------
TW_API_KEY = os.environ.get("TWITTER_API_KEY")
TW_API_SECRET = os.environ.get("TWITTER_API_SECRET")

REQUEST_TOKEN_URL = "https://api.twitter.com/oauth/request_token"
AUTHORIZE_URL     = "https://api.twitter.com/oauth/authorize"
ACCESS_TOKEN_URL  = "https://api.twitter.com/oauth/access_token"

# -----------------------------
# Utilities
# -----------------------------

def provider_from_query() -> str:
    p = (request.args.get("provider") or request.form.get("provider") or "").lower()
    if p not in PROVIDERS:
        raise ValueError("Unsupported provider")
    return p

# -----------------------------
# Routes
# -----------------------------
@app.get("/")
def home():
    return jsonify({"ok": True, "message": "BudgetHero OAuth service running", "providers": list(PROVIDERS)})

@app.get("/auth/login")
def auth_login():
    provider = provider_from_query()
    redirect_uri = f"{BASE_URL}/auth/callback/{provider}"

    if provider == "google":
        return oauth.google.authorize_redirect(redirect_uri)
    if provider == "microsoft":
        # prompt=select_account already configured
        return oauth.microsoft.authorize_redirect(redirect_uri)
    if provider == "github":
        return oauth.github.authorize_redirect(redirect_uri)
    if provider == "twitter":
        # OAuth 1.0a — get request token then redirect to authorize URL
        if not TW_API_KEY or not TW_API_SECRET:
            return make_response("Twitter keys missing", 500)
        client = OAuth1Session(TW_API_KEY, TW_API_SECRET)
        data = client.fetch_request_token(REQUEST_TOKEN_URL, params={"oauth_callback": f"{BASE_URL}/auth/callback/twitter"})
        oauth_token = data.get("oauth_token")
        url = f"{AUTHORIZE_URL}?{urlencode({'oauth_token': oauth_token})}"
        return redirect(url)

    return make_response("Unknown provider", 400)

@app.get("/auth/callback/<provider>")
def auth_callback(provider: str):
    provider = provider.lower()
    if provider not in PROVIDERS:
        return make_response("Unsupported provider", 400)

    profile = None

    if provider == "google":
        token = oauth.google.authorize_access_token()
        # Minimal profile
        me = oauth.google.get("userinfo").json()
        profile = {
            "provider": "google",
            "id": me.get("id"),
            "email": me.get("email"),
            "name": me.get("name"),
            "picture": me.get("picture"),
        }

    elif provider == "microsoft":
        token = oauth.microsoft.authorize_access_token()
        me = oauth.microsoft.get("me").json()
        profile = {
            "provider": "microsoft",
            "id": me.get("id"),
            "email": me.get("userPrincipalName"),
            "name": me.get("displayName"),
        }

    elif provider == "github":
        token = oauth.github.authorize_access_token()
        me = oauth.github.get("user").json()
        emails = oauth.github.get("user/emails").json()
        primary_email = None
        if isinstance(emails, list):
            for e in emails:
                if e.get("primary"):
                    primary_email = e.get("email")
                    break
            if not primary_email and emails:
                primary_email = emails[0].get("email")
        profile = {
            "provider": "github",
            "id": me.get("id"),
            "email": primary_email,
            "name": me.get("name") or me.get("login"),
            "avatar_url": me.get("avatar_url"),
        }

    elif provider == "twitter":
        # Exchange request token for access token
        oauth_token = request.args.get("oauth_token")
        oauth_verifier = request.args.get("oauth_verifier")
        client = OAuth1Session(TW_API_KEY, TW_API_SECRET)
        tokens = client.fetch_access_token(ACCESS_TOKEN_URL, params={
            "oauth_token": oauth_token,
            "oauth_verifier": oauth_verifier,
        })
        # Twitter 1.0a gives screen_name & user_id; email requires elevated perms
        profile = {
            "provider": "twitter",
            "id": tokens.get("user_id"),
            "screen_name": tokens.get("screen_name"),
        }

    # Issue our own JWT for API auth
    user_claims = {
        "sub": f"{profile.get('provider')}:{profile.get('id')}",
        "email": profile.get("email"),
        "name": profile.get("name") or profile.get("screen_name"),
        "provider": profile.get("provider"),
    }
    jwt = jwt_encode(user_claims, exp_seconds=60*60*24*7)  # 7 days

    # Redirect back to your SPA with the JWT as a fragment (avoid logs)
    redirect_to = f"{BASE_URL}/login-success#token={jwt}"
    return redirect(redirect_to)

@app.post("/auth/logout")
def auth_logout():
    # Stateless JWT — client should just delete it. This endpoint exists for symmetry.
    return jsonify({"ok": True, "message": "Client must delete JWT; no server session stored."})

@app.get("/auth/switch")
def auth_switch():
    # Convenience: front-end calls this to start a switch flow
    try:
        provider = provider_from_query()
    except Exception as e:
        return make_response(str(e), 400)
    # Front-end should drop local JWT first; we just redirect to login
    return redirect(url_for("auth_login", provider=provider))

# -----------------------------
# Example protected API route using JWT
# -----------------------------

def require_jwt(fn):
    def wrapper(*args, **kwargs):
        auth = request.headers.get("Authorization", "")
        if not auth.startswith("Bearer "):
            return make_response(jsonify({"message": "Unauthorized"}), 401)
        token = auth.split(" ", 1)[1].strip()
        try:
            user = jwt_decode(token)
        except Exception as e:
            return make_response(jsonify({"message": "Unauthorized", "error": str(e)}), 401)
        request.user = user
        return fn(*args, **kwargs)
    wrapper.__name__ = fn.__name__
    return wrapper

@app.get("/api/me")
@require_jwt
def api_me():
    return jsonify({"user": request.user})

# -----------------------------
# Plaid relink helper (call when switching BudgetHero accounts)
# -----------------------------
@app.post("/api/plaid/unlink")
@require_jwt
def unlink_plaid():
    # In your real app, delete the stored access_token/item for this user
    # Then the client should call /api/plaid/link_token to start a new Link session
    return jsonify({"ok": True, "message": "Plaid access revoked for this user (server-side delete)."})

# -----------------------------
# Run server
# -----------------------------
if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=True)
