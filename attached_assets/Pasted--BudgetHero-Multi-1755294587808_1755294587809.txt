// ─────────────────────────────────────────────────────────────────────────────
// BudgetHero Multi‑Provider OAuth — Node.js + Express + TypeScript (Replit‑ready)
// Providers: Google, Microsoft (Outlook), GitHub, X/Twitter (OAuth 1.0a)
// Features: Forced account selection (where supported), clean logout, switch
//           account, JWT issuance, protected route, Plaid unlink helper.
//
// Files in this single doc:
//   1) package.json
//   2) tsconfig.json
//   3) src/server.ts
//   4) .env.example (for your Replit Secrets)
// Copy each section into files with the same names in your Replit project.
// ─────────────────────────────────────────────────────────────────────────────

/*
------------------------- 1) package.json -------------------------
{
  "name": "budgethero-oauth-node-ts",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js"
  },
  "dependencies": {
    "axios": "^1.7.2",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "oauth-1.0a": "^2.2.6",
    "qs": "^6.12.1"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.12.12",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.4.5"
  }
}

------------------------- 2) tsconfig.json -------------------------
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Node",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}

------------------------- 3) src/server.ts -------------------------
*/
import express, { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import axios from 'axios';
import crypto from 'crypto';
import OAuth from 'oauth-1.0a';
import qs from 'qs';

// Load env from Replit Secrets; on local dev you can use dotenv
const {
  PORT = '5000',
  BASE_URL = `http://localhost:5000`,
  JWT_SECRET = 'change_me',

  // Google
  GOOGLE_CLIENT_ID,
  GOOGLE_CLIENT_SECRET,

  // Microsoft (Outlook)
  MS_CLIENT_ID,
  MS_CLIENT_SECRET,
  MS_TENANT = 'common',

  // GitHub
  GH_CLIENT_ID,
  GH_CLIENT_SECRET,

  // Twitter (X) OAuth 1.0a
  TWITTER_API_KEY,
  TWITTER_API_SECRET,
} = process.env as Record<string, string>;

const app = express();
app.use(express.json());

// ─────────────────────────────────────────────────────────────────────────────
// Helpers: JWT
// ─────────────────────────────────────────────────────────────────────────────
function signJWT(payload: object, expiresIn: string | number = '7d') {
  return jwt.sign(payload, JWT_SECRET, { algorithm: 'HS256', expiresIn });
}

function verifyJWT(token?: string) {
  if (!token) throw new Error('Missing token');
  return jwt.verify(token, JWT_SECRET) as any;
}

// Middleware to protect routes
function requireJWT(req: Request, res: Response, next: NextFunction) {
  const auth = req.headers.authorization || '';
  if (!auth.startsWith('Bearer ')) return res.status(401).json({ message: 'Unauthorized' });
  const token = auth.slice('Bearer '.length);
  try {
    (req as any).user = verifyJWT(token);
    next();
  } catch (e: any) {
    return res.status(401).json({ message: 'Unauthorized', error: e?.message });
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// Providers config
// ─────────────────────────────────────────────────────────────────────────────
const PROVIDERS = new Set(['google', 'microsoft', 'github', 'twitter']);

// Google OAuth 2.0
const GOOGLE_AUTH = {
  authorize: 'https://accounts.google.com/o/oauth2/v2/auth',
  token: 'https://oauth2.googleapis.com/token',
  userinfo: 'https://www.googleapis.com/oauth2/v2/userinfo',
  scope: 'openid email profile',
};

// Microsoft (Outlook) — v2 endpoint supports personal and work accounts
const MS_AUTH = {
  authorize: `https://login.microsoftonline.com/${MS_TENANT}/oauth2/v2.0/authorize`,
  token: `https://login.microsoftonline.com/${MS_TENANT}/oauth2/v2.0/token`,
  userinfo: 'https://graph.microsoft.com/v1.0/me',
  scope: 'openid email profile offline_access User.Read',
};

// GitHub OAuth 2.0
const GH_AUTH = {
  authorize: 'https://github.com/login/oauth/authorize',
  token: 'https://github.com/login/oauth/access_token',
  user: 'https://api.github.com/user',
  emails: 'https://api.github.com/user/emails',
  scope: 'read:user user:email',
};

// Twitter (X) OAuth 1.0a endpoints
const TWITTER_AUTH = {
  requestToken: 'https://api.twitter.com/oauth/request_token',
  authorize: 'https://api.twitter.com/oauth/authorize',
  accessToken: 'https://api.twitter.com/oauth/access_token',
};

function getProvider(req: Request) {
  const p = (req.query.provider as string | undefined)?.toLowerCase();
  if (!p || !PROVIDERS.has(p)) throw new Error('Unsupported provider');
  return p;
}

// ─────────────────────────────────────────────────────────────────────────────
// Routes
// ─────────────────────────────────────────────────────────────────────────────
app.get('/', (_req, res) => {
  res.json({ ok: true, message: 'BudgetHero OAuth service running', providers: [...PROVIDERS] });
});

// Begin login
app.get('/auth/login', async (req, res) => {
  try {
    const provider = getProvider(req);
    const redirectUri = `${BASE_URL}/auth/callback/${provider}`;

    if (provider === 'google') {
      const params = qs.stringify({
        client_id: GOOGLE_CLIENT_ID,
        redirect_uri: redirectUri,
        response_type: 'code',
        scope: GOOGLE_AUTH.scope,
        include_granted_scopes: 'true',
        access_type: 'offline',
        prompt: 'select_account', // Force account chooser
      });
      return res.redirect(`${GOOGLE_AUTH.authorize}?${params}`);
    }

    if (provider === 'microsoft') {
      const params = qs.stringify({
        client_id: MS_CLIENT_ID,
        redirect_uri: redirectUri,
        response_type: 'code',
        scope: MS_AUTH.scope,
        prompt: 'select_account',
      });
      return res.redirect(`${MS_AUTH.authorize}?${params}`);
    }

    if (provider === 'github') {
      const params = qs.stringify({
        client_id: GH_CLIENT_ID,
        redirect_uri: redirectUri,
        scope: GH_AUTH.scope,
        allow_signup: 'true',
      });
      return res.redirect(`${GH_AUTH.authorize}?${params}`);
    }

    if (provider === 'twitter') {
      if (!TWITTER_API_KEY || !TWITTER_API_SECRET) return res.status(500).send('Twitter keys missing');
      // OAuth 1.0a request token
      const oauth = new OAuth({
        consumer: { key: TWITTER_API_KEY, secret: TWITTER_API_SECRET },
        signature_method: 'HMAC-SHA1',
        hash_function(base_string, key) {
          return crypto.createHmac('sha1', key).update(base_string).digest('base64');
        },
      });
      const requestData = {
        url: TWITTER_AUTH.requestToken,
        method: 'POST',
        data: { oauth_callback: `${BASE_URL}/auth/callback/twitter` },
      } as any;
      const headers = oauth.toHeader(oauth.authorize(requestData));
      const resp = await axios.post(TWITTER_AUTH.requestToken, qs.stringify({ oauth_callback: `${BASE_URL}/auth/callback/twitter` }), { headers: { ...headers, 'Content-Type': 'application/x-www-form-urlencoded' } });
      const parsed = qs.parse(resp.data);
      const oauth_token = parsed['oauth_token'];
      return res.redirect(`${TWITTER_AUTH.authorize}?oauth_token=${oauth_token}`);
    }

    return res.status(400).send('Unknown provider');
  } catch (e: any) {
    return res.status(400).json({ error: e?.message || 'Auth error' });
  }
});

// OAuth callbacks
app.get('/auth/callback/:provider', async (req, res) => {
  const provider = (req.params.provider || '').toLowerCase();
  try {
    const redirectUri = `${BASE_URL}/auth/callback/${provider}`;

    if (provider === 'google') {
      const { data: token } = await axios.post(GOOGLE_AUTH.token, qs.stringify({
        code: req.query.code,
        client_id: GOOGLE_CLIENT_ID,
        client_secret: GOOGLE_CLIENT_SECRET,
        redirect_uri: redirectUri,
        grant_type: 'authorization_code',
      }), { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } });

      const { data: me } = await axios.get(GOOGLE_AUTH.userinfo, { headers: { Authorization: `Bearer ${token.access_token}` } });
      const claims = {
        sub: `google:${me.id}`,
        email: me.email,
        name: me.name,
        provider: 'google',
      };
      const jwtToken = signJWT(claims);
      return res.redirect(`${BASE_URL}/login-success#token=${jwtToken}`);
    }

    if (provider === 'microsoft') {
      const { data: token } = await axios.post(MS_AUTH.token, qs.stringify({
        code: req.query.code,
        client_id: MS_CLIENT_ID,
        client_secret: MS_CLIENT_SECRET,
        redirect_uri: redirectUri,
        grant_type: 'authorization_code',
      }), { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } });

      const { data: me } = await axios.get(MS_AUTH.userinfo, { headers: { Authorization: `Bearer ${token.access_token}` } });
      const claims = {
        sub: `microsoft:${me.id}`,
        email: me.userPrincipalName,
        name: me.displayName,
        provider: 'microsoft',
      };
      const jwtToken = signJWT(claims);
      return res.redirect(`${BASE_URL}/login-success#token=${jwtToken}`);
    }

    if (provider === 'github') {
      // Exchange code for access token
      const { data: tokenResp } = await axios.post(GH_AUTH.token, {
        client_id: GH_CLIENT_ID,
        client_secret: GH_CLIENT_SECRET,
        code: req.query.code,
        redirect_uri: redirectUri,
      }, { headers: { Accept: 'application/json' } });

      const accessToken = tokenResp.access_token;
      const { data: user } = await axios.get(GH_AUTH.user, { headers: { Authorization: `Bearer ${accessToken}`, Accept: 'application/json' } });
      const { data: emails } = await axios.get(GH_AUTH.emails, { headers: { Authorization: `Bearer ${accessToken}`, Accept: 'application/json' } });
      let primaryEmail = Array.isArray(emails) ? emails.find((e: any) => e.primary)?.email : undefined;
      if (!primaryEmail && Array.isArray(emails) && emails.length) primaryEmail = emails[0].email;

      const claims = {
        sub: `github:${user.id}`,
        email: primaryEmail,
        name: user.name || user.login,
        provider: 'github',
      };
      const jwtToken = signJWT(claims);
      return res.redirect(`${BASE_URL}/login-success#token=${jwtToken}`);
    }

    if (provider === 'twitter') {
      // OAuth 1.0a: exchange oauth_token + oauth_verifier for access token
      const oauth_token = req.query.oauth_token as string;
      const oauth_verifier = req.query.oauth_verifier as string;
      const resp = await axios.post(TWITTER_AUTH.accessToken, qs.stringify({ oauth_token, oauth_verifier }), { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } });
      const parsed = qs.parse(resp.data as string);
      const claims = {
        sub: `twitter:${parsed['user_id']}`,
        name: parsed['screen_name'],
        provider: 'twitter',
      };
      const jwtToken = signJWT(claims);
      return res.redirect(`${BASE_URL}/login-success#token=${jwtToken}`);
    }

    return res.status(400).json({ error: 'Unsupported provider' });
  } catch (e: any) {
    return res.status(400).json({ error: e?.response?.data || e?.message || 'Callback error' });
  }
});

// Stateless logout — client should delete JWT
app.post('/auth/logout', (_req, res) => {
  res.json({ ok: true, message: 'Client must delete JWT locally; no server session stored.' });
});

// Convenience: switch = (client clears JWT) + start new login
app.get('/auth/switch', (req, res) => {
  try {
    const provider = getProvider(req);
    return res.redirect(`/auth/login?provider=${provider}`);
  } catch (e: any) {
    return res.status(400).json({ error: e?.message });
  }
});

// Example protected route
app.get('/api/me', requireJWT, (req, res) => {
  res.json({ user: (req as any).user });
});

// Plaid unlink helper — when switching BudgetHero accounts, remove stored item/access token
app.post('/api/plaid/unlink', requireJWT, (_req, res) => {
  // TODO: delete user's Plaid item/access_token in your DB
  res.json({ ok: true, message: 'Plaid access revoked for this user (server-side delete).' });
});

app.listen(parseInt(PORT, 10), () => {
  console.log(`BudgetHero OAuth server listening on ${BASE_URL} (PORT ${PORT})`);
});

/*
------------------------- 4) .env.example -------------------------
# Replit: add these as Secrets (no quotes). BASE_URL = your public HTTPS URL
PORT=8000
BASE_URL=https://your-repl-name.username.repl.co
JWT_SECRET=change_me

# Google OAuth
GOOGLE_CLIENT_ID=...
GOOGLE_CLIENT_SECRET=...

# Microsoft OAuth (Outlook) — Azure App Registration
MS_CLIENT_ID=...
MS_CLIENT_SECRET=...
MS_TENANT=common

# GitHub OAuth
GH_CLIENT_ID=...
GH_CLIENT_SECRET=...

# X / Twitter OAuth 1.0a
TWITTER_API_KEY=...
TWITTER_API_SECRET=...

# CALLBACKS to register in each provider console:
#   {BASE_URL}/auth/callback/google
#   {BASE_URL}/auth/callback/microsoft
#   {BASE_URL}/auth/callback/github
#   {BASE_URL}/auth/callback/twitter

*/